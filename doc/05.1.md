# 5.1 协程

在前面的章节[2.4](<2.4.md>)介绍了协程的原理及PHP用户空间如何实现协程,本节将重点介绍MSF框架的协程如何使用,同时会剖析PHP工程级协程调度器的实现及调度算法。

## 为什么要使用协程?

至于为什么使用协程,可能大家看法还不统一,这里举例来说明,我们实现一个接口,此接口内包含:

2次http请求其他接口A、B,

1次Redis请求C

他们之间的依赖关系为:`((A && B) || C)`

```
<?php
/**
 * 拉取用户推荐列表
 */
namespace App\Controllers\Api;

use PG\MSF\Controllers\Controller;
use App\Models\Feed;
use App\Tasks\Idallloc;

class Pr extends Controller
{
    /**
     * 异步回调的方式实现(A && B) || C
     */
    public function httpCallBackMode()
    {
        $client = new \swoole_redis;
        $client->connect('127.0.0.1', 6379, function (\swoole_redis $client, $result) {
            $client->get('apiCacheForABCallBack', function (\swoole_redis $client, $result) {
                if (!$result) {
                    swoole_async_dns_lookup("www.baidu.com", function($host, $ip) use ($client) {
                        $cli = new \swoole_http_client($ip, 443, true);
                        $cli->setHeaders([
                            'Host' => $host,
                        ]);
                        $apiA = "";
                        $cli->get('/', function ($cli) use ($client, $apiA) {
                            $apiA = $cli->body;
                            swoole_async_dns_lookup("www.qiniu.com", function($host, $ip) use ($client, $apiA) {
                                $cli = new \swoole_http_client($ip, 443, true);
                                $cli->setHeaders([
                                    'Host' => $host,
                                ]);
                                $apiB = "";
                                $cli->get('/', function ($cli) use ($client, $apiA, $apiB) {
                                    $apiB = $cli->body;
                                    if ($apiA && $apiB) {
                                        $client->set('apiCacheForABCallBack', $apiA . $apiB, function (\swoole_redis $client, $result) {});
                                        $this->outputJson($apiA . $apiB);
                                    } else {
                                        $this->outputJson('', 'error');
                                    }
                                });
                            });
                        });
                    });
                } else {
                    $this->outputJson($result);
                }
            });
        });
    }

    /**
     * 协程的方式实现(A && B) || C
     */
    public function httpCoroutineMode()
    {
        // 从Redis获取get apiCacheForABCoroutine
        $getRedisCoroutine = $this->getRedisPool('tw')->get('apiCacheForABCoroutine');
        $response          = yield $getRedisCoroutine;
        if (!$response) {
            // 从对象池中获取Http Client
            $client     = $this->getContext()->getObjectPool()->get(\PG\MSF\Client\Http\Client::class);
            // 异步dns解析
            $dnsACor    = $client->coroutineGetHttpClient('https://www.baidu.com');
            $dnsBCor    = $client->coroutineGetHttpClient('https://www.qiniu.com');
            // 获取dns解析的结果
            $httClientA = yield $dnsACor;
            $httClientB = yield $dnsBCor;
            // 异步拉取数据
            $resultACor = $httClientA->coroutineGet('/');
            $resultBCor = $httClientB->coroutineGet('/');
            // 获取拉取数据的结果
            $resultA    = yield $resultACor;
            $resultB    = yield $resultBCor;
            // 写入redis
            $setRedisCoroutine = $this->getRedisPool('tw')->set('apiCacheForABCoroutine', $resultA['body'] . $resultB['body']);
            yield $setRedisCoroutine;
            $response   = $resultA['body'] . $resultB['body'];
        }

        // 响应结果
        $this->outputJson($response);
    }
}
```

http://127.0.0.1:8000/api/pr/callbackmode

http://127.0.0.1:8000/api/pr/coroutinemode

1. 异步非阻塞的IO模型

# links
  * [目录](<preface.md>)
  * 上一节: [框架组件](<05.0.md>)
  * 下一节: [类的加载](<05.2.md>)