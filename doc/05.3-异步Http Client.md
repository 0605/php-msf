# 5.3 异步Http Client

支持协程的异步Http Client很关键,在微服务系统框架中,服务与服务的交互大多是通过Http接口来实现,即使有封装RPC,也大多在Http Client的基础上,当然我们也可以选择自定义的Tcp文本或者二进制协议,这里我们主要介绍MSF框架中的Http Client的实现与使用。本节中的示例代码:[./php-msf/app/Controllers/Api/Pr.php](https://github.com/PGWireless/php-msf/blob/app/app/Controllers/Api/Pr.php)

## 实现

框架对http client的支持是基于swoole_http_client,同时在此基础上封装了dns查询、简单快捷操作、多个请求并行的各种方法。

## 基本用法

```php
<?php
/**
 * 拉取用户推荐列表
 */
namespace App\Controllers\Api;

use PG\MSF\Controllers\Controller;
use App\Models\Feed;
use App\Tasks\Idallloc;

class Pr extends Controller
{
    // 略...
    /**
     * 获取百度首页,手工进行DNS解析和数据拉取
     *
     * @throws \PG\MSF\Base\Exception
     */
    public function httpBaiduIndexWithOutDNS()
    {
        /**
         * @var $client \PG\MSF\Client\Http\Client
         */
        $client     = $this->getContext()->getObjectPool()->get(\PG\MSF\Client\Http\Client::class);
        $sendDNS    = $client->coroutineGetHttpClient('http://www.baidu.com');
        /**
         * @var $httpClient \PG\MSF\Client\Http\HttpClient
         */
        $httpClient = yield $sendDNS;
        $sendGet    = $httpClient->coroutineGet('/');
        $result     = yield $sendGet;

        $this->outputView(['html' => $result['body']]);
    }
}
```

这种用户将一个Http请求方法分成为两步:第一步是:DNS查询,第二步是Get请求。可能大家会很奇怪,不就一个Http请求嘛,还分两步?其实我们原来使用CURL扩展的时候,也是这两个步骤,只是CURL内部把我们完成了DNS查询。

另外,由于DNS查询是一次UDP的请求,PHP内置函数`string gethostbyname ( string $hostname )`是同步阻塞模式,如果使用这个函数,将使我们的Sever退化为同步Server,MSF框架进行DNS查询使用了`swoole_async_dns_lookup()`进行异步DNS解析。

一个http请求,开发代码进行两次yield,开发效率不高,但是性能是最好的;同时我们也提供一些快捷的方法,在只有一次接口请求的开发中性能和效率均可得到提升。

## 自动DNS解析

```php
<?php
/**
 * 拉取用户推荐列表
 */
namespace App\Controllers\Api;

use PG\MSF\Controllers\Controller;
use App\Models\Feed;
use App\Tasks\Idallloc;

class Pr extends Controller
{
    // 略...
    /**
     * 获取百度首页,自动进行DNS
     *
     * @throws \PG\MSF\Base\Exception
     */
    public function httpBaiduIndexWithDNS()
    {
        /**
         * @var $client \PG\MSF\Client\Http\Client
         */
        $client     = $this->getContext()->getObjectPool()->get(\PG\MSF\Client\Http\Client::class);
        /**
         * @var $httpClient \PG\MSF\Client\Http\HttpClient
         */
        $httpClient = yield $client->coroutineHttpClientWithDNS('http://www.baidu.com');
        $sendGet    = $httpClient->coroutineGet('/');
        $result     = yield $sendGet;

        $this->outputView(['html' => $result['body']]);
    }
}
```

`\PG\MSF\Client\Http\Client::coroutineHttpClientWithDNS()`帮你完成了DNS解析,非常适用在一个接口中多次请求其他api接口。

## 快捷POST/GET

```php
<?php
/**
 * 拉取用户推荐列表
 */
namespace App\Controllers\Api;

use PG\MSF\Controllers\Controller;
use App\Models\Feed;
use App\Tasks\Idallloc;

class Pr extends Controller
{
    // 略...
    /**
     * 获取百度首页,自动进行DNS,自动通过Get拉取数据
     *
     * @throws \PG\MSF\Base\Exception
     */
    public function httpBaiduIndexGet()
    {
        /**
         * @var $client \PG\MSF\Client\Http\Client
         */
        $client = $this->getContext()->getObjectPool()->get(\PG\MSF\Client\Http\Client::class);
        $result = yield $client->coroutineGet('http://www.baidu.com/');

        $this->outputView(['html' => $result['body']]);
    }

    /**
     * 获取百度首页,自动进行DNS,自动通过Get拉取数据
     *
     * @throws \PG\MSF\Base\Exception
     */
    public function httpBaiduIndexPost()
    {
        /**
         * @var $client \PG\MSF\Client\Http\Client
         */
        $client = $this->getContext()->getObjectPool()->get(\PG\MSF\Client\Http\Client::class);
        $result = yield $client->coroutinePost('http://www.baidu.com/');

        $this->outputView(['html' => $result['body']]);
    }
}
```

`\PG\MSF\Client\Http\Client::coroutineGet()`,`\PG\MSF\Client\Http\Client::coroutinePost()`两个方法可以快捷的自动完成DNS和请求的发送,直接返回响应内容。

## 响应数据

```
[
    'errCode' => 0
    'sock' => 17
    'host' => '180.97.33.107'
    'port' => 80
    'headers' => [
        'content-type' => 'text/html'
        'content-encoding' => 'gzip'
        'cache-control' => 'no-cache'
        'pragma' => 'no-cache'
        'content-length' => '363'
        'set-cookie' => 'bai=16.;Domain=.baidu.com;Path=/;Max-Age=10'
    ]
    'type' => 1025
    'requestHeaders' => [
        'Host' => 'www.baidu.com'
        'X-Ngx-LogId' => '59496e12c3474d040f41fda2'
    ]
    'requestBody' => null
    'cookies' => [
        'bai' => '16.'
    ]
    'set_cookie_headers' => [
        'bai' => 'bai=16.;Domain=.baidu.com;Path=/;Max-Age=10'
    ]
    'body' => '<body></body><script type=\"text/javascript\">u=\"https://www.baidu.com/?tn=93817326_hao_pg\";d=document;/webkit/i.test(navigator.userAgent)?(f=d.createElement(\'iframe\'),f.style.width=1,f.style.height=1,f.frameBorder=0,d.body.appendChild(f).src=\'javascript:\"<script>top.location.replace(\\\'\'+u+\'\\\')<\\/script>\"\'):(d.open(),d.write([\'<meta http-equiv=\"refresh\"content=\"0;url=\',\'\"/>\'].join(u)),d.close());function g(k){return v=eval(\"/\"+k+\"=(.*?)(&|$)/i.exec(location.href)\"),v?v[1]:\"\"}</script>'
    'statusCode' => 200
]
```

其中:

errCode的具体含义:[附录：Linux错误信息(errno)列表](https://wiki.swoole.com/wiki/page/172.html)

statusCode为Http响应的状态码:

[维基百科HTTP状态码](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81)

[OSCHINA HTTP状态码](http://tool.oschina.net/commons?type=5)

body为响应正文

## 并行请求

Http请求分成了DNS查询和发送数据两个异步部分,从而在多个内部接口请求中会写大量的冗余代码的,故框架封装了简单实用的并行的Http Client,要使用并行请求,首页需要进行配置。

### server配置

```php
<?php
$config['params']['service']['baidu']['host']    = 'http://www.baidu.com';
$config['params']['service']['baidu']['timeout'] = 1000;

return $config;
```

注册了名为baidu的服务,注意`$config['params']['service']`配置项代表所有的注册服务

`$config['params']['service']['baidu']['host']`服务地址与协议,如:`http://www.baidu.com`

`$config['params']['service']['baidu']['timeout']`服务对应的域名解析超时时间,单位ms

示例代码:

[./php-msf/app/config/docker/service.php](https://github.com/PGWireless/php-msf/blob/app/config/docker/service.php)

### parallel配置

```php
<?php
/**
 * @desc: parallel配置 对比之前的批量请求配置
 * @author: leandre <niulingyun@camera360.com>
 * @date: 14/06/2017
 * @copyright All rights reserved.
 */
/**
 * name => [
 *      'service' => 'servA', // 必须在 $config['params']['service'] 里配置 servA 的 host、timeout
 *      'url' => 'urlA',  //   eg: /api/info
 *      'method' => 'GET OR POST'   // 可选 优先使用parallel配置，然后有参数有POST，无参用GET
 *      'timeout' => 200 // 可选， 优先使用
 * ]
 */
$config['params']['parallel'] = [
    'baidu' => [
        'service' => 'baidu',
        'url'     => '/',
        'parser'  => 'none',
    ],
    'baidu1' => [
        'service' => 'baidu',
        'url'     => '/',
        'parser'  => 'none',
    ],
    'baidu2' => [
        'service' => 'baidu',
        'url'     => '/',
        'parser'  => 'none',
    ],
    'baidu3' => [
        'service' => 'baidu',
        'url'     => '/',
        'parser'  => 'none',
    ],
];

return $config;
```

配置了四个接口,注意`$config['params']['parallel']`代表并发Http Client支持的接口

如:

`$config['params']['parallel']['baidu1']['url']`请求的URI,如/api/rec/query

`$config['params']['parallel']['baidu1']['parser']`接口响应之后,解析响应正文的解析器名称,默认为`normal`,会使用json_decode进行解析。如果不通过解析器需要配置为`none`

`$config['params']['parallel']['baidu1']['timeout']`接口请求的超时时间,单位ms

`$config['params']['parallel']['baidu1']['method']`接口请求发送的请求方法,默认GET;当有其他请求参数是会发送POST请求。

### 并发请求

```php
<?php
    /**
     * 并行多次获取百度首页,自动进行DNS,自动通过Get拉取数据
     */
    function httpConcurrentBaiduIndexGet()
    {
        $requests = [
            // key为接口名,和$config['params']['parallel']对应,value为请求的参数
            'baidu' => [
                'a' => 1,
            ],
            // key为接口名,value为请求的参数
            'baidu1' => [
                'a' => 2,
            ],
            // key为接口名,value为请求的参数
            'baidu2' => [
                'a' => 3,
            ],
            // key为接口名,value为请求的参数
            'baidu3' => [
                'a' => 4,
            ]
        ];

        $results = yield \PG\MSF\Client\ConcurrentClient::request($requests, $this);

        $this->outputJson($results);
    }
```

# links
  * [目录](<preface-目录.md>)
  * 上一节: [类的加载](<05.2-类的加载.md>)
  * 下一节: [请求上下文](<05.4-请求上下文.md>)