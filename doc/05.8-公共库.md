# 5.8 公共库
## 过滤器
过滤器用于权限控制、公共参数校验、签名校验等，是为网站提供安全保障的一环。

### ActionFilter
这个类是所有过滤器的基类。所有过滤器都继承自它。

### 新加一个过滤器
继承 `\PG\Filter\ActionFilter`，实现 `runFilter` 方法即可。

### 使用方式
  1. 在父级控制器配置过滤组件，如： 
```
/**
 * 过滤器
 * [
 *     'access' => [
 *         'class' => AccessCheckFilter::class,
 *         'only' => ['xx',...], // 仅仅对哪些method有效
 *         'except' => ['xx',...], // 除了对这些method有效
 *         'rules' => $this->accessRules()
 *     ],
 *     ...
 * ]
 *
 * @return array
 */
protected function filters()
{
    // 注意先后顺序，建议 CheckCommonParameters 放在最前面
    return [
        'CheckCommonParameters' => [
            'class' => \PG\PT\Utils\Filters\CheckCommonParameters::class,
            'only' => ['httpIndex'],
        ],
        'VerifySign' => [
            'class' => \PG\PT\Utils\Filters\VerifySign::class,
            'appSecret' => 'xxx',
            'godSig' => 'xxx',
        ],
        'access' => [
            'class' => \PG\PT\Utils\Filters\AccessControl::class,
            'async' => true,
            'rules' => $this->accessRules(),
        ]
    ];
}
```
组件 `class` 选项必须配置，用于指定组件类。选项 `async` 表示该过滤器的执行使用异步方式，异步方式会在调取执行方法前加 `yield` 关键字。除了4个保留关键字（另外两个是 `only` 和 `except`），也可指定类属性的初始值（会自动映射上去），如上例中的VerifySign下的`appSecret` 选项。

  2. 在父级控制器中新增 `runFilter` 方法，如： 
```
/**
 * 执行 filter 逻辑
 *
 * @throws \Exception
 */
protected function runFilter()
{
    $filters = $this->filters();
    if (empty($filters)) {
        return;
    }
    // 此处 Request 对象为过滤器提供所需要的参数，如控制器名，方法名、ip、get/post等参数。
    /* @var $request Request */
    $request = $this->objectPool->get(Request::class);
    $request->init($this->controllerName, $this->methodName);
    $request->ip = $this->ip;
    $request->request = $this->reqParams;

    foreach ($filters as $filter) {
        if (!isset($filter['class'])) {
            throw new \Exception('Filter config need class prop.');
        }
        $clazz = $this->objectPool->get($filter['class']);
        $async = !empty($filter['async']);
        unset($filter['class'], $filter['async']);
        foreach ($filter as $prop => $val) {
            $clazz->$prop = $val;
        }
        $clazz->initialization();
        if ($async) { // 异步方式，在调用方法前加 yield
            $result = yield call_user_func([$clazz, 'beforeMethod'], $request);
        } else {
            $result = call_user_func([$clazz, 'beforeMethod'], $request);
        }
        if ($result === false) { // 校验失败，被拒绝.
            $clazz->denyCallback();
        }
        // 公共参数取回
        if ($clazz instanceof CheckCommonParameters) {
            $this->setCommonParameters($clazz);
        }
    }
}
```
  3. 在父级控制器中的 `initialization` 方法中调用runFilter方法：`$this->runFilter()`

### 过滤器未通过返回值
规定：过滤器返回 `false` 或者抛出异常表示验证失败。

## ACF
MSF ACF过滤器提供了用户访问控制管理，区分为登录用户和游客（非登录用户）。作为MSF内置过滤器`filter`的一员，使用方式同其他filter，只是需要单独配置访问规则，如：
```
/**
 * 过滤规则
 */
public function accessRules()
{
    return [
        [
            'methods' => ['httpFetch'],
            'allow' => true,
            'roles' => [] // httpFetch 允许所有用户访问
        ],
        [
            'methods' => ['httpDel', 'httpAdd'],
            'allow' => true,
            'roles' => ['@'] // httpDel、httpAdd 只允许登录用户访问
        ],
        [
            'methods' => ['httpLogin'],
            'allow' => true,
            'roles' => ['?'] // httpLogin只允许游客访问
        ]
    ];
}
```
### ACF role规则说明：
@：登录用户
?：游客（非登录用户）

# links
  * [目录](<preface-目录.md>)
  * 上一节: [RPC](<05.7-RPC.md>)
  * 下一节: [RESTful](<05.9-RESTful.md>)