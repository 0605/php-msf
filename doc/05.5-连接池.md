# 5.5 连接池

连接池的重要性,这时就不赘述了,下面具体介绍框架中实现的哪些连接池。

有关于连接池有一个配置项

```
//启动一个新进程维护连接池
$config['asyn_process_enable'] = false;
```

## Redis连接池

### 主要特性

- 支持异步+协程
- 支持断线重连
- 支持自动提取和归还连接

### 配置

```php
<?php
/**
 * 本地环境
 */
$config['redis']['tw']['ip']               = '127.0.0.1';
$config['redis']['tw']['port']             = 6379;
//$config['redis']['tw']['password']       = 'xxxx';
//$config['redis']['tw']['select']         = 1;
// Redis序列化选项等同于phpredis序列化的各个选项如:\Redis::SERIALIZER_PHP,\Redis::SERIALIZER_IGBINARY
//$config['redis']['tw']['redisSerialize'] = \Redis::SERIALIZER_PHP;
// PHP序列化选项,为了兼容yii迁移项目的set,get,mset,mget,选项如:\Redis::SERIALIZER_PHP,\Redis::SERIALIZER_IGBINARY
//$config['redis']['tw']['phpSerialize']   = \Redis::SERIALIZER_NONE;
// 是否将key md5后储存,默认为0,开启为1
//$config['redis']['tw']['hashKey']        = 1;
// 设置key的前缀
//$config['redis']['tw']['keyPrefix']      = 'hotpot_';
return $config;
```

示例配置代码:

[./php-msf/app/config/docker/redis.php](https://github.com/PGWireless/php-msf/blob/app/config/docker/redis.php)

- $config['redis']

代表Redis连接池相关配置

- tw

这里的tw仅代表一台或者一组Redis服务器,在使用连接池时会用到,如果Redis服务器端分片（比如twemproxy）就填写为集群导出的地址与端口等信息。

- ip

Redis服务器地址

- port

Redis服务器端口

- password

Redis认证密钥

- select

Redis DB

- redisSerialize

Redis序列化选项等同于phpredis序列化的各个选项如:\Redis::SERIALIZER_PHP,\Redis::SERIALIZER_IGBINARY

- phpSerialize

PHP序列化选项,为了兼容yii迁移项目的set,get,mset,mget,选项如:\Redis::SERIALIZER_PHP,\Redis::SERIALIZER_IGBINARY

- hashKey

是否将key md5后储存,默认为0,开启为1

- keyPrefix

设置key的前缀

### Redis连接池的使用

```php
<?php
/**
 * 拉取用户推荐列表
 */
namespace App\Controllers\Api;

use PG\MSF\Controllers\Controller;
use App\Models\Feed;
use App\Tasks\Idallloc;

class Pr extends Controller
{
    /**
     * Redis连接池的使用
     */
    public function httpRedisPoolUsage()
    {
        /**
         * 获取名为tw的Redis连接池,并发送set操作指令
         */
        $setKey1 = $this->getRedisPool('tw')->set('key1', 'val1');
        $setKey2 = $this->getRedisPool('tw')->set('key2', 'val2');
        $setKey3 = $this->getRedisPool('tw')->set('key3', 'val3');
        /**
         * 获取名为tw的Redis连接池,并发送get操作指令
         */
        $getKey1 = $this->getRedisPool('tw')->get('key1');
        $getKey2 = $this->getRedisPool('tw')->get('key2');
        $getKey3 = $this->getRedisPool('tw')->get('key3');
        /**
         * 获取set的返回结果
         */
        $ret1    = yield $setKey1;
        $ret2    = yield $setKey2;
        $ret3    = yield $setKey3;
        /**
         * 获取get的返回结果
         */
        $ret4    = yield $getKey1;
        $ret5    = yield $getKey2;
        $ret6    = yield $getKey3;

        if ($ret1 && $ret2 && $ret3 && $ret4 && $ret5 && $ret6) {
            $this->outputJson('ok');
        } else {
            $this->outputJson('error');
        }
    }
}
```

1. $this->getRedisPool($name)

获取连接池对象,并选择名为$name的连接池,$name由配置文件中声明,比如上述配置中的tw

2. 连接池对象的所有方法映射为标准的Redis操作指令

如:`SETEX key seconds value`映射为`$this->getRedisPool($name)->setex($key, $seconds, $value)`

3. string类型的简化操作

`$this->getRedisPool($name)->cache($key, $value = '', $expire = 0)`,`$key`为redis key,`$value`为缓存的值,`$expire`为过期时间,默认不会过期。

4. 执行lua脚本

`$this->getRedisPool($name)->evalMock($script, $args = array(), $numKeys = 0)`

如:

```php
<?php
function luaExample()
{
    $num = 100;
    $lua = "
           local allWorks = {}
           local recWorks = {}
           local random = nil
           for k, v in pairs(KEYS) do
               local works = redis.call('sRandMember', v, '" . $num . "')
               if works ~= nil then
                   for key, val in pairs(works) do
                       table.insert(allWorks, val)
                   end
               end
           end
           while #recWorks < " . $num . " and #allWorks > 0 do
               random = math.random(#allWorks)
               table.insert(recWorks, allWorks[random])
               table.remove(allWorks, random)
           end
           return cjson.encode(recWorks)
       ";
    $keys = ['feedId1', 'feedId2', 'feedId3'];
    $this->getRedisPool('tw')->evalMock($lua, $keys, count($keys));
}
```

## Redis代理

在Redis连接池的基本上,MSF框架还实现了Redis代理的基本功能,主要特性有:

- 支持分布式自动分片
- 支持master-slave读写分离
- 支持故障自动failover

### 配置

```php
<?php
/**
 * 本地环境
 */
$config['redis']['tw']['ip']               = '127.0.0.1';
$config['redis']['tw']['port']             = 6379;
//$config['redis']['tw']['password']       = 'xxxx';
//$config['redis']['tw']['select']         = 1;
// Redis序列化选项等同于phpredis序列化的各个选项如:\Redis::SERIALIZER_PHP,\Redis::SERIALIZER_IGBINARY
//$config['redis']['tw']['redisSerialize'] = \Redis::SERIALIZER_PHP;
// PHP序列化选项,为了兼容yii迁移项目的set,get,mset,mget,选项如:\Redis::SERIALIZER_PHP,\Redis::SERIALIZER_IGBINARY
//$config['redis']['tw']['phpSerialize']   = \Redis::SERIALIZER_NONE;
// 是否将key md5后储存,默认为0,开启为1
//$config['redis']['tw']['hashKey']        = 1;
// 设置key的前缀
//$config['redis']['tw']['keyPrefix']      = 'hotpot_';

$config['redis']['tw1']['ip']               = '127.0.0.1';
$config['redis']['tw1']['port']             = 6380;

$config['redis']['read_only']['ip']         = '127.0.0.1';
$config['redis']['read_only']['port']       = 6381;

$config['redis_proxy']['cluster'] = [
    'pools' => [
        'tw'  => 1,
        'tw1' => 1,
    ],
    'mode' => \PG\MSF\Marco::CLUSTER,
];

$config['redis_proxy']['master_slave'] = [
    'pools' => [
        'tw', 'read_only',
    ],
    'mode' => \PG\MSF\Marco::MASTER_SLAVE,
];

return $config;
```

示例配置代码:

[./php-msf/app/config/docker/redis.php](https://github.com/PGWireless/php-msf/blob/app/config/docker/redis.php)

- $config['redis_proxy']

代表Redis代理相关配置

- cluster

这里的cluster仅代表一组Redis服务器集群,是一个标识

- mode

Redis集群类型,\PG\MSF\Marco::CLUSTER代表分布式的Redis集群;\PG\MSF\Marco::MASTER_SLAVE代表主从结构的Redis集群

- pools

当mode设置为\PG\MSF\Marco::CLUSTER时,pools为array,他的key表示Redis连接池名称,value表示Redis连接池权重;当mode设置为\PG\MSF\Marco::MASTER_SLAVE,pools为英文逗号分隔的Redis连接池名称列表。

### Redis代理的使用

```php
<?php
/**
 * 拉取用户推荐列表
 */
namespace App\Controllers\Api;

use PG\MSF\Controllers\Controller;
use App\Models\Feed;
use App\Tasks\Idallloc;

class Pr extends Controller
{
    // ...
    /**
     * Redis代理的使用
     *
     * @throws \PG\MSF\Base\Exception
     */
    public function httpRedisProxyUsage()
    {
        $this->getContext()->getLog()->profileStart('no-yield');
        for ($i = 1; $i < 100; $i++) {
            // 设置100个key到Redis集群,并且不需要获取返回值
            $this->getRedisProxy('cluster')->set('cs-' . $i, $i*$i);
        }
        $this->getContext()->getLog()->profileEnd('no-yield');

        $this->getContext()->getLog()->profileStart('has-yield');
        for ($i = 1; $i < 100; $i++) {
            // 设置100个key到Redis集群,并且需要获取返回值
            $sendSetKey[$i] = $this->getRedisProxy('cluster')->set('cs-' . $i, $i*$i);
        }
        for ($i = 1; $i < 100; $i++) {
            $res[$i] = yield $sendSetKey[$i];
        }
        $this->getContext()->getLog()->profileEnd('has-yield');

        // 设置key为user_id_111,value为name111到主从结构的Redis集群
        $this->getRedisProxy('master_slave')->set('user_id_111', 'name111');

        $this->outputJson('ok');
    }
}
```

## Redis连接池与代理的关系

![Redis连接池与代表的关系](./images/redis连接池和代理.png "Redis连接池与代表的关系")

## MySQL连接池

完善中...

# links
  * [目录](<preface-目录.md>)
  * 上一节: [请求上下文](<05.4-请求上下文.md>)
  * 下一节: [对象池](<05.6-对象池.md>)