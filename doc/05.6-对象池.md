# 5.6 对象池

对象池服务可以减少从头创建每个对象的系统开销。在需要对象时从池中提取,在使用完对象时，把它放回池中,等待下一个请求。对象池使你能够控制所使用的对象数量。在PHP的长驻进程模式下,对象池尤其重要,由于PHP的GC缺陷,在高并发下,PHP长驻进程内直接通过new创建对象,会导致PHP进程占用大量的内存,而且很容易出现OOM(out of memory)。

## 主要特性

- 创建固定数量的对象；
- 需要时从池中提取，不需要时归还池中；
- 自动归还对象；
- 根据有效期和使用次数淘汰对象

## 获取对象池

```
$this->getContext()->getObjectPool()
```

理论上基于MSF框架的任何代码都可以通过请求上下文对象来获取对象池对象

## 获取对象

如获取Http Client对象:

```
$client = $this->getContext()->getObjectPool()->get(\PG\MSF\Client\Http\Client::class)
```

**需要特别注意的是: 基于MSF框架的应用,除了Model/Controller/Task/View不通过对象池来创建对象,其他类的实例强烈 建议通过对象池创建与管理**

### 初始化对象

由于对象池模式创建对象,类的构造方法只会被调用一次,故传统的通过构造方法初始化对象的策略就不生效。需要我们在代码中显示调用初始化对象的方法如:

```
$this->getContext()->getObjectPool()->get(FeedComment::class)->initialization($fid, $page);
```

### 资源释放

className::destroy()

每一个类,理论上都需要定义destroy()方法,用于资源的手工释放,但是不需要显示调用,在请求结束时由框架自动调用。

对于和请求相关的数据,理论上我们是需要在请求结束后释放相关资源,框架对于资源释放的策略及优先级如下:

1. 响应请求后调用Controller::destroy()
2. 依次调用当前请求所使用的对象的destroy()方法
3. 将所有public的类属性的值设置为初始值

通常情况下,destroy方法用于处理private,protected的类属性,public由框架自动清理。

如下示例:

```php
<?php
/**
 * 内部服务抽象
 *
 * @author camera360_server@camera360.com
 * @copyright Chengdu pinguo Technology Co.,Ltd.
 */
namespace PG\InnerServ;

use PG\Exception\Errno;
use PG\Helper\CommonHelper;
use PG\AOP\Factory;

abstract class InnerServ
{

    /**
     * @var string 环境配置，支持 production, testing, develop
     */
    protected $mode = '';
    /**
     * @var string 机房配置，支持 aws,aliyun
     */
    protected $idc = '';
    /**
     * @var null
     */
    protected $appType = null;
    /**
     * @var int
     */
    protected $timeout = 3000;
    /**
     * @var Context
     */
    public $context;

    /**
     * 环境映射
     * @var array
     */
    public $envMap = [
        'production_cn_bj' => ['production_cn_bj', 'production'], // 北京正式环境
        'production_en' => ['production_en', 'production-en'], // 海外正式环境
        'qa' => ['qa', 'testing'], // qa 测试环境
        'dev' => ['dev', 'testing_dev'], // 研发测试环境
        'docker' => ['docker', 'newdev', 'development'] // 本地开发环境
    ];

    /**
     * 初始化环境配置 & IDC 配置 & 应用类型
     */
    public function initialization()
    {
        $this->initIdc();
        $this->initMode();
        $this->initAppType();
    }

    /**
     * @return Context
     */
    public function getContext()
    {
        return $this->context;
    }

    /**
     * @return int
     */
    public function getTimeout()
    {
        return $this->timeout;
    }

    /**
     * @param int $timeout
     */
    public function setTimeout($timeout)
    {
        $this->timeout = $timeout;
    }

    /**
     * @return string
     */
    public function getMode()
    {
        return $this->mode;
    }

    /**
     * 设置所属环境
     * @param string $mode
     * @throws \Exception
     */
    public function setMode($mode)
    {
        if (in_array($mode, $this->envMap['production_en'])) {
            $this->mode = 'production_en';
        } elseif (in_array($mode, $this->envMap['production_cn_bj'])) {
            $this->mode = 'production_cn_bj';
        } elseif (in_array($mode, $this->envMap['qa'])) {
            $this->mode = 'qa';
        } elseif (in_array($mode, $this->envMap['dev'])) {
            $this->mode = 'dev';
        } elseif (in_array($mode, $this->envMap['docker'])) {
            $this->mode = 'docker';
        } else {
            throw new \Exception("mode config $mode error", Errno::INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * @param $idc
     * @throws \Exception
     */
    public function setIdc($idc)
    {
        if (!in_array($idc, [
            'aws',
            'aliyun'
        ])
        ) {
            throw new \Exception("idc config $idc error", Errno::INTERNAL_SERVER_ERROR);
        }
        $this->idc = $idc;
    }

    /**
     * @return string
     */
    public function getIdc()
    {
        return $this->idc;
    }

    /**
     * 根据机器名初始化idc配置
     */
    protected function initIdc()
    {
        if ($this->idc) {
            return true;
        }
        $hostname = gethostname();
        // aws的机器都是cn-bj开始的
        if (substr($hostname, 0, 5) == 'cn-bj') {
            $this->setIdc('aws');
        }
        // aliyun是cloud或app开始的
        if (substr($hostname, 0, 5) == 'cloud' || substr($hostname, 0, 3) == 'app') {
            $this->setIdc('aliyun');
        } else {
            // aws环境
            $this->setIdc('aws');
        }
    }

    /**
     * 根据APPLICATION_ENV初始化mode配置
     */
    protected function initMode()
    {
        if (defined('APPLICATION_ENV') && !$this->mode) {
            try {
                $this->setMode(APPLICATION_ENV);
            } catch (\Exception $e) {
                $this->setMode('docker');
            }
        }
    }

    /**
     * 初始化 php运行模式
     */
    protected function initAppType()
    {
        $this->appType = CommonHelper::getAppType();
    }

    /**
     * 用于对象回收时调用，主要场景是使用到了对象池
     */
    public function destory()
    {
        $this->mode = '';
        $this->idc = '';
        $this->appType = null;
        $this->timeout = 3000;
    }

    /**
     * 实例化inner serv对象
     *
     * @param string $service
     * @param \PG\Context\AbstractContext | null $context
     *
     * @return \PG\AOP\Wrapper|\stdClass
     */
    public static function get($service, $context = null)
    {
        if (!empty($context) && ($context instanceof \PG\MSF\Helpers\Context)) {
            $serv = $context->getObjectPool()->get($service);
        } else {
            $serv = new $service;
        }
        $aopServ = Factory::createAdapterObject($serv);

        return $aopServ;
    }
}
````

## 对象池实现原理

![对象池实现原理](./images/对象池实现原理.png "对象池实现原理")

## PHP进程内存优化

对象池模式对PHP进程占用的内存优化可以说“完全超出预期”,如下图所示:

![内存优化-30d.png](./images/内存优化-30d.png "内存优化-30d.png")

上图为近30天基于MSF重构的社区首页业务的其中一台机器的一个worker进程内存占用的监控数据,从图中有几点:

1. 5-10~5-27,近15天内存占用波峰达1.25G,波谷的值在持续的攀升;
2. 5-27~5-31,近5天内存占用从一个较低的点持续攀升;
3. 6-01之后,内存占用持续稳定在25M上下小辐波动;

在1阶段,框架大量类的对象是直接使用new关键字创建,完全依赖的PHP GC进行内存资源的回收;

在2阶段,框架采用对象池的方案完全重构大量的逻辑,效果很明显,但仍然有部分内存泄露;

在3阶段,优化了业务逻辑,完全按照“资源释放”的策略调整业务代码,内存占用已稳定。


# links
  * [目录](<preface-目录.md>)
  * 上一节: [连接池](<05.5-连接池.md>)
  * 下一节: [RPC](<05.7-RPC.md>)